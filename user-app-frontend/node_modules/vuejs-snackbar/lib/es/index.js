/**
 * Bundle of vuejs-snackbar
 * Generated: 2019-06-06
 * Version: 4.0.1
 * License: MIT
 * Author: livelybone(2631541504@qq.com)
 */

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

//
//
//
//
//
//
//
//
//
//
//
//
//
//

var validator = function validator(msg) {
  if (typeof msg !== 'string' && typeof msg.message !== 'string') {
    return 'Parameter msg is invalid. Expected a String, or an Object with property message[type:String].';
  }
  return msg;
};
var getStyle = function getStyle(baseSize, position) {
  var _wrap;

  var c = function c(f) {
    return 'calc(' + f + ' * ' + baseSize + ')';
  };
  var pos = position.pos,
      textAlign = position.textAlign;

  return {
    wrap: (_wrap = {
      position: 'fixed',
      left: 0
    }, defineProperty(_wrap, pos, c(0.05)), defineProperty(_wrap, 'zIndex', 1000), defineProperty(_wrap, 'width', '100%'), defineProperty(_wrap, 'padding', '0 ' + c(0.2)), defineProperty(_wrap, 'pointerEvents', 'none'), defineProperty(_wrap, 'textAlign', textAlign), _wrap),
    bar: function bar(bg) {
      return {
        display: 'inline-block',
        width: 'auto',
        minWidth: baseSize,
        maxWidth: 'calc(100vw - ' + c(0.4) + ')',
        padding: c(0.15) + ' ' + c(0.2),
        margin: '0 0 ' + c(0.05),
        borderRadius: c(0.02),
        lineHeight: c(0.2),
        color: '#fff',
        background: bg,
        boxShadow: '0 ' + c(0.01) + ' ' + c(0.025) + ' rgba(0,0,0, .15)',
        cursor: 'pointer',
        textAlign: 'center',
        pointerEvents: 'all',
        userSelect: 'none'
      };
    }
  };
};
var script = {
  name: 'SnackBar',
  props: {
    colors: {
      default: function _default() {
        return {
          open: '#333',
          info: '#3DBD7D',
          error: '#FA7377',
          warn: '#FF6600'
        };
      },

      type: Object
    },
    holdTime: {
      default: 3000,
      type: Number
    },
    multiple: {
      default: true,
      type: Boolean
    },
    wrapClass: String,
    baseSize: {
      default: '100px',
      type: String
    },
    position: {
      default: 'top-center',
      type: String
    }
  },
  data: function data() {
    return {
      msgs: []
    };
  },

  computed: {
    $_baseSize: function $_baseSize() {
      return (/\d(rem|px|em)$/.test(this.baseSize) ? this.baseSize : '100px'
      );
    },
    $_position: function $_position() {
      var _position$toString$sp = this.position.toString().split('-'),
          _position$toString$sp2 = slicedToArray(_position$toString$sp, 2),
          p = _position$toString$sp2[0],
          textAlign = _position$toString$sp2[1];

      return {
        pos: ['top', 'bottom'].includes(p) ? p : 'top',
        textAlign: ['left', 'center', 'right'].includes(textAlign) ? textAlign : 'center'
      };
    },
    style: function style() {
      return getStyle(this.$_baseSize, this.$_position);
    }
  },
  methods: {
    info: function info(msg) {
      var color = this.colors.info;
      this.open({ color: color, msg: msg }, false);
      return true;
    },
    error: function error(msg) {
      var color = this.colors.error;
      this.open({ color: color, msg: msg }, false);
      return false;
    },
    warn: function warn(msg) {
      var color = this.colors.warn;
      this.open({ color: color, msg: msg }, false);
      return true;
    },
    open: function open(message) {
      var isOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var msg = void 0;
      var color = void 0;
      if (!isOpen) {
        color = message.color;

        msg = validator(message.msg);
      } else {
        color = this.colors.open;
        msg = validator(message);
      }

      var msgObj = {
        color: color,
        msg: msg,
        timer: setTimeout(this.pop, this.holdTime)
      };
      if (this.multiple) {
        this.msgs.push(msgObj);
      } else {
        this.pop(0);
        this.msgs = [msgObj];
      }
      return true;
    },
    pop: function pop() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.msgs[i]) clearTimeout(this.msgs[i].timer);
      this.msgs.splice(i, 1);
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function __vue_render__() {
  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "snack-bar-wrap", class: _vm.wrapClass, style: _vm.wrapClass ? '' : _vm.style.wrap }, [_vm._l(_vm.msgs, function (msg, i) {
    return [_c('div', { key: i, staticClass: "snack-bar", style: _vm.wrapClass ? '' : _vm.style.bar(msg.color), domProps: { "innerHTML": _vm._s(msg.msg.message || msg.msg) }, on: { "click": function click($event) {
          return _vm.pop(i);
        } } }), _vm._v(" "), _c('br', { key: i + '1' })];
  })], 2);
};
var __vue_staticRenderFns__ = [];

/* style */
var __vue_inject_styles__ = undefined;
/* scoped */
var __vue_scope_id__ = undefined;
/* module identifier */
var __vue_module_identifier__ = undefined;
/* functional template */
var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

var Snackbar = normalizeComponent_1({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

export default Snackbar;
